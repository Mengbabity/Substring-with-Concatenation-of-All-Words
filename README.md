# Substring-with-Concatenation-of-All-Words

问题：给了一个字符串和一组单词（单词长度相等），返回由所有单词连接而成的子字符串的开始下标。

开始的想法：for循环不以字符串大小为准，而是以单词个数为准，当单词遍历结束，则说明存在子字符串，可不能保证连续性。

解决方法：将单词放入一个map中。m为单词长度，n为单词个数。count记录子字符串出现的单词个数。
         通过一个窗口来表示子字符串的界限，用left记录下标。重要的思想是，按照string.sub来查找字符串中匹配的单词，而不是匹配char。
         外层for循环以单词大小m为界，因为开始的下标若为m，和从0遍历是一样的。
         内层for循环从i开始，并在j小于等于m时停止，每次加m。
找匹配和连续   if 当sub出匹配的单词，用map记录，若个数小于单词表的个数，count++.否则全部暂时使用的变量归零，即只要内循环出现一个else，表明不连续！
消除重复       if 当有重复单词出现，即个数大于单词表的个数，窗口滑动一个单词的位置，若此时把最左边的单词滑没了，少了一个匹配单词，count--。直至不重复。
         最后，若找到了子字符串，即count==单词个数，pushback即可。
